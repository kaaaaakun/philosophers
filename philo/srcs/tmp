/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_philosopers.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tokazaki <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/10/19 13:14:54 by tokazaki          #+#    #+#             */
/*   Updated: 2023/10/19 13:17:13 by tokazaki         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

philo_info	*philosophers_and_mutex_struct_init(int argc, char *argv)
{
	philosophers_info philo_info;

	philo_info = (philo_info *) malloc (sizeof(philo_info) * 1);
	if (phino_info == NULL)
		exit (1);
	philo_info->num_of_philosophers =  argv[1];
    philo_info->time_to_deth = argv[2];
    philo_info->time_to_eat = argv[3];
    philo_info->time_to_sleep = argv[4];
	if (argc == 5)
		philo_info->eat_count = argv[5];
	
}

int	exec_philosopers(int argc, char *argv)
{
	philosophers_info	*philo_info;
//哲学者の初期化
	philo_info = philosophers_and_mutex_struct_init(argc, argv);

//mutexの初期化
	mutex_info = mutex_struct_init(phi);
    pthread_mutex_init(&mutex, NULL);
    pthread_mutex_init(&print, NULL);

//threadの初期化
    ThreadInfo info1 = {1, &cnt, &mutex, &print};
    ThreadInfo info2 = {2, &cnt, &mutex, &print};

//threadの作成
    pthread_create(&p1, NULL, routine, (void *)&info1);
    pthread_create(&p2, NULL, routine, (void *)&info2);

//他のthreadを待つ
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

//mutexの破壊
    pthread_mutex_destroy(&mutex);
    pthread_mutex_destroy(&print);

//値の表示
    printf("Final cnt -> %d\n", cnt);

    return 0;
	(void)argc;
	(void)argv;

}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tokazaki <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/10/19 13:17:32 by tokazaki          #+#    #+#             */
/*   Updated: 2023/10/19 15:55:36 by tokazaki         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

//void *routine(void *arg)
//{
//    ThreadInfo *info = (ThreadInfo *)arg;
//
//    for (int i = 0; i < 5; i++) {
//        pthread_mutex_lock(info->mutex_ptr);
//        (*(info->cnt_ptr))++;
//        pthread_mutex_unlock(info->mutex_ptr);
//
//        pthread_mutex_lock(info->print_ptr);
//        printf("Thread %d incremented cnt to %d\n", info->thread_id, *(info->cnt_ptr));
//        pthread_mutex_unlock(info->print_ptr);
//    }
//    return NULL;
//}

int main(int argc, char *argv)
{
	t_philo_routine_data	routine_data;
//引数のチェック
	routine_data = check_args_and_make_routine_data(argc, argv)
	if (routine_data == NULL)
		return (1);	
	exec_philosopers();
//	exit();
////mutexの初期化
//    pthread_mutex_init(&mutex, NULL);
//    pthread_mutex_init(&print, NULL);
//
////threadの初期化
//    ThreadInfo info1 = {1, &cnt, &mutex, &print};
//    ThreadInfo info2 = {2, &cnt, &mutex, &print};
//
////threadの作成
//    pthread_create(&p1, NULL, routine, (void *)&info1);
//    pthread_create(&p2, NULL, routine, (void *)&info2);
//
////他のthreadを待つ
//    pthread_join(p1, NULL);
//    pthread_join(p2, NULL);
//
////mutexの破壊
//    pthread_mutex_destroy(&mutex);
//    pthread_mutex_destroy(&print);
//
////値の表示
//    printf("Final cnt -> %d\n", cnt);
    return 0;
	(void)argc;
	(void)argv;

}

t_philo_routine_data	*check_args_and_make_routine_data(int argc, char *argv)
{
	int						flag;
	t_philo_routine_data	routine_data;

	flag = INIT;
	if (!(argc == 5 || argc == 6))
		return (NULL);
	routine_data = (t_philo_routine_data *) malloc (sizeof(t_philo_routine_data) * 1);
	if (routine_data == NULL)
		return (NULL);
	routine_data->num_of_philo = philo_atoi(argv[1]);
	routine_data->time_to_die = philo_atoi(argv[2]);
	routine_data->time_to_eat = philo_atoi(argv[3]);
	routine_data->time_to_sleep = philo_atoi(argv[4]);
	if (argc == 6)
		routine_data->eat_count = philo_atoi(argv[5]);
	else
		routine_data->eat_count = -1;
	if (flag == ARGS_ERROR)
	{	
		free(routine_data);
		routine_data == NULL;
	}
	return (routine_data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   philo_atoi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tokazaki <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/10/19 13:32:37 by tokazaki          #+#    #+#             */
/*   Updated: 2023/10/19 15:55:03 by tokazaki         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <limits.h>

static long long int	plus_atoi(const char *str, int *flag)
{
	long long int	result;
	long long int	l_divis;
	char			l_remain;
	int				i;

	i = 0;
	result = 0;
	l_divis = LONG_MAX / 10;
	l_remain = LONG_MAX % 10 + '0';
	if (!ft_isdigit(str[i]))
	{
		return (0);
	}
	while (ft_isdigit(str[i]))
	{
		if ((l_divis == result && l_remain < str[i])
			|| l_divis < result)
			return (LONG_MAX);
		result = result * 10 + (str[i] - '0');
		if (INT_MAX < result)
			*flag = ARGS_ERROR;
		i++;
	}
	if (str[i] != '\0')
		*flag = ARGS_ERROR;
	return (result);
}

static long long int	minus_atoi(const char *str, int *flag)
{
	long long int	result;
	long long int	l_divis;
	char			l_remain;
	int				i;

	i = 0;
	result = 0;
	l_divis = LONG_MIN / 10;
	l_remain = (LONG_MIN % 10 * -1) + '0';
	while (ft_isdigit(str[i]))
	{
		if ((l_divis == result && l_remain < str[i])
			|| l_divis > result)
			return (LONG_MIN);
		result = result * 10 - (str[i] - '0');
		if (result < INT_MIN)
			*flag = ARGS_ERROR;
		i++;
	}
	if (str[i] != '\0')
		*flag = ARGS_ERROR;
	return (result);
}

int	philo_atoi(const char *str, int *flag)
{
	long long int	result;

	if (*str == '-')
	{
		str++;;
		*flag = ARGS_ERROR;
		result = minus_atoi(str, flag);
	}
	else
	{
		if (*str == '+')
		{
			str++;
			*flag = ARGS_ERROR;
		}
		result = plus_atoi(str, flag);
	}
	if (result == 0)
		*flag = ARGS_ERROR;
	return (result);
}
